# 继承

继承，主要解决的是共性抽取。子类继承了父类，就拥有父类所有的成员变量和成员方法。除此之外，子类还可以拥有自己的内容。子类与父类的关系，可以这么理解：子类就是一个父类。比如父类是人，子类是学生，子类就是父类说的就是**学生是人**。也叫`is-a`关系。

## 继承的格式

子类通过`extends`关键字基础父类，而父类的定义与一般类的定义相同，现在假设有一个父类`Person`和一个子类`Student`。

```java
public class Person {
    String name;
    int age;
    
    public void showA() {
        System.out.println("我是父类的方法");
    }
}
```

```java
public class Student extends Person {
    int id; //子类拥有父类的成员变量和成员方法
}
```

## 子类访问父类成员变量

上面讲过，一旦子类继承了父类，那么子类就拥有子类的所有成员变量和成员方法。那么子类怎么访问父类的成员变量，这里分为重名和不重名两种

- 不重名
  - 这种情况最简单，这时是直接用子类对象`.`父类的成员变量就可以访问

```java
Student stu = new Student();
stu.name;
stu.age;
```

- 重名
  - 直接
    - 如果使用子类对象`.`的话，访问的就是子类的成员变量
  - 间接
    - 间接指的就是通过成员方法访问，此时举个例子说明

假设父类有一个`int num;`，子类也有一个`int num;`。现在父类有一个`showA`方法如下

```java
public void showA() {
    System.out.println(num);
}
```

那么如果子类对象调用这个方法的话，那么使用的就是父类的`num`。现在如果子类有一个`showB`方法，如下

```java
public void showB() {
    System.out.println(num);
}
```

如果子类对象调用这个方法，那么使用就是子类的`num`。简而言之，方法属于谁，就用谁的。

## 区分三种变量

这三种变量指的就是

- 父类的成员变量
- 子类的成员变量
- 局部变量

之前我们讲过区分局部变量和成员变量，我们使用`this`关键字加以区分。现在假设在子类的一个成员方法中，父类，子类有成员变量`name`，而该方法也有一个局部变量，这时我们这么区分，如下：

```java
super.name;      //父类的name
this.name;       //子类的name
name             //局部变量name
```

同理，如果子类有成员方法和父类的一个成员方法重名的话，如果我们想在子类的某个成员方法中使用父类的这个成员方法的话，我们可以使用`super.父类方法()`调用。`super`这个关键字指的就是父类对象。

## 重写

之前我们有多次提到重写的概念，那么重写是什么？重写指的就是子类的某个方法与父类的方法的方法名称一样，参数列表也一样，相当于把父类的这个方法覆盖了。当我们使用子类对象`.`这个方法时，优先使用子类的方法。



重写的方法需要满足一定的要求，如下：

- 必须父子类方法名相同，参数列表相同
- 子类方法的返回值范围要小于父类方法`(Object > String)`
- 子类方法的权限必须大于等于父类的权限操作符

```java
//权限修饰符的大小熟悉怒
public > protected > (default) > private
```



**注意：**

- 有一个注解，`@Override`，把它放在要重写的方法前面，可以检查是否重写正确，比如你重写的方法漏掉了一个字母，这相当于你自己有了一个新的成员方法，并不是重写，编译器不会报错，这可能会造成问题，因为你是想重写的。但是你如果在方法前面加上`@Override`，它会检查这个方法是不是重写，如果不是会报错。这个是可选的，但是推荐使用。

```java
@Override    //写在方法的前面
public void show() {
    
}
```

## 继承中的构造方法

为了讲解清楚，假设有两个类，一个是`Person`类，是父类，另一个是`Student`类，是子类。两个方法的定义如下

```java
public class Person {
    
    public Person() {
        System.out.println("父类的构造方法")
    }
}
```

```java
public class Student extends Person{

    public Student() {
        System.out.println("我是子类的构造方法");
    }
}
```

我要讲的是，在子类构造方法的第一行，默认有`super();`，这个代表调用父类的构造方法，即在调用子类构造方法时，会先调用父类的无参构造方法，现在我们创建一个`Student`对象，看看打印输出

```java
public class TestExtends {
    public static void main(String[] args) {
        Student student = new Student();
    }
}
```

打印输出为

```java
我是父类的构造方法
我是子类的构造方法
```

可见是默认会调用父类的无参构造方法。所以我们在之前建议为类写一个无参的构造方法，因为在创建子类对象时会先调用父类的无参构造方法，如果父类没有的话，会报错。

注意：

- `super`调用必须是第一个语句，比如下面会报错

```java
public Student() {
    System.out.println("我是子类的构造方法");
    super(); //会报错，因为不是第一个语句
}
```

- 这也意味着在方法中只能调用一次`super()`方法，因为第二个`super`不是第一个语句了

```java
public Student() {
    super();
    super("name",12);  //假设父类有一个有参构造方法 由于不是第一个语句，报错
                       //这意味着只能调用一个super()方法
    System.out.println("我是子类的构造方法");
    
}
```

-  `this()`可以调用本类的构造方法，`this()`也必须是第一个语句，所以`this()`和`super()`不能同时出现。

## 继承的三个特征

- `Java`语言是单继承的，只能有一个直接父类
- 可以有多级继承，继承的源头是`Object`
- 一个子类的直接父类是唯一的，但是可以有多个子类

